const { getDatabase, saveDatabase } = require('../config/database');
const path = require('path');

class TaggingService {
  constructor() {
    this.defaultColors = [
      '#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6',
      '#EC4899', '#14B8A6', '#F97316', '#6366F1', '#84CC16'
    ];
  }

  /**
   * Create tag
   */
  async createTag(userId, name, color = null, autoGenerated = false) {
    try {
      const db = getDatabase();
      
      // Check if tag already exists
      const existing = db.exec(
        `SELECT id FROM tags 
         WHERE user_id = ${userId} AND name = '${name}'`
      )[0];

      if (existing && existing.values.length > 0) {
        return this.getTag(existing.values[0][0]);
      }

      // Use random color if not provided
      if (!color) {
        color = this.defaultColors[Math.floor(Math.random() * this.defaultColors.length)];
      }

      db.run(
        `INSERT INTO tags (user_id, name, color, auto_generated)
         VALUES (?, ?, ?, ?)`,
        [userId, name, color, autoGenerated ? 1 : 0]
      );

      saveDatabase();

      const result = db.exec(
        `SELECT * FROM tags 
         WHERE user_id = ${userId} 
         ORDER BY id DESC LIMIT 1`
      )[0];

      if (result && result.values.length > 0) {
        return this.formatTag(result.values[0]);
      }
    } catch (error) {
      console.error('Error creating tag:', error);
      throw error;
    }
  }

  /**
   * Get tag by ID
   */
  async getTag(tagId) {
    try {
      const db = getDatabase();
      
      const result = db.exec(
        `SELECT * FROM tags WHERE id = ${tagId}`
      )[0];

      if (!result || !result.values.length) {
        return null;
      }

      return this.formatTag(result.values[0]);
    } catch (error) {
      console.error('Error getting tag:', error);
      return null;
    }
  }

  /**
   * Get user tags
   */
  async getUserTags(userId) {
    try {
      const db = getDatabase();
      
      const result = db.exec(
        `SELECT t.*, COUNT(ft.id) as file_count
         FROM tags t
         LEFT JOIN file_tags ft ON t.id = ft.tag_id
         WHERE t.user_id = ${userId}
         GROUP BY t.id
         ORDER BY t.name ASC`
      )[0];

      if (!result || !result.values.length) {
        return [];
      }

      return result.values.map(row => ({
        ...this.formatTag(row),
        fileCount: row[5]
      }));
    } catch (error) {
      console.error('Error getting user tags:', error);
      return [];
    }
  }

  /**
   * Update tag
   */
  async updateTag(tagId, userId, updates) {
    try {
      const db = getDatabase();
      
      const { name, color } = updates;
      
      const sets = [];
      const values = [];
      
      if (name !== undefined) {
        sets.push('name = ?');
        values.push(name);
      }
      if (color !== undefined) {
        sets.push('color = ?');
        values.push(color);
      }
      
      values.push(tagId, userId);
      
      db.run(
        `UPDATE tags 
         SET ${sets.join(', ')}
         WHERE id = ? AND user_id = ?`,
        values
      );

      saveDatabase();

      return await this.getTag(tagId);
    } catch (error) {
      console.error('Error updating tag:', error);
      throw error;
    }
  }

  /**
   * Delete tag
   */
  async deleteTag(tagId, userId) {
    try {
      const db = getDatabase();
      
      db.run(
        'DELETE FROM tags WHERE id = ? AND user_id = ?',
        [tagId, userId]
      );

      saveDatabase();

      return { success: true };
    } catch (error) {
      console.error('Error deleting tag:', error);
      throw error;
    }
  }

  /**
   * Add tag to file
   */
  async addTagToFile(fileId, tagName, userId, autoGenerated = false) {
    try {
      const db = getDatabase();
      
      // Get or create tag
      let tag = await this.getTagByName(userId, tagName);
      if (!tag) {
        tag = await this.createTag(userId, tagName, null, autoGenerated);
      }

      // Add tag to file
      try {
        db.run(
          'INSERT INTO file_tags (file_id, tag_id) VALUES (?, ?)',
          [fileId, tag.id]
        );
        saveDatabase();
      } catch (error) {
        // Ignore duplicate entries
        if (!error.message.includes('UNIQUE constraint')) {
          throw error;
        }
      }

      return tag;
    } catch (error) {
      console.error('Error adding tag to file:', error);
      throw error;
    }
  }

  /**
   * Remove tag from file
   */
  async removeTagFromFile(fileId, tagId) {
    try {
      const db = getDatabase();
      
      db.run(
        'DELETE FROM file_tags WHERE file_id = ? AND tag_id = ?',
        [fileId, tagId]
      );

      saveDatabase();

      return { success: true };
    } catch (error) {
      console.error('Error removing tag from file:', error);
      throw error;
    }
  }

  /**
   * Get file tags
   */
  async getFileTags(fileId) {
    try {
      const db = getDatabase();
      
      const result = db.exec(
        `SELECT t.* FROM tags t
         INNER JOIN file_tags ft ON t.id = ft.tag_id
         WHERE ft.file_id = ${fileId}
         ORDER BY t.name ASC`
      )[0];

      if (!result || !result.values.length) {
        return [];
      }

      return result.values.map(row => this.formatTag(row));
    } catch (error) {
      console.error('Error getting file tags:', error);
      return [];
    }
  }

  /**
   * Get files by tag
   */
  async getFilesByTag(tagId, userId) {
    try {
      const db = getDatabase();
      
      const result = db.exec(
        `SELECT f.* FROM files f
         INNER JOIN file_tags ft ON f.id = ft.file_id
         WHERE ft.tag_id = ${tagId} 
         AND f.user_id = ${userId}
         AND f.status = 'active'
         ORDER BY f.uploaded_at DESC`
      )[0];

      if (!result || !result.values.length) {
        return [];
      }

      return result.values;
    } catch (error) {
      console.error('Error getting files by tag:', error);
      return [];
    }
  }

  /**
   * Get tag by name
   */
  async getTagByName(userId, name) {
    try {
      const db = getDatabase();
      
      const result = db.exec(
        `SELECT * FROM tags 
         WHERE user_id = ${userId} AND name = '${name}'`
      )[0];

      if (!result || !result.values.length) {
        return null;
      }

      return this.formatTag(result.values[0]);
    } catch (error) {
      console.error('Error getting tag by name:', error);
      return null;
    }
  }

  /**
   * Auto-tag file based on rules
   */
  async autoTagFile(fileId, userId) {
    try {
      const db = getDatabase();
      
      // Get file info
      const fileResult = db.exec(
        `SELECT filename, mimetype FROM files WHERE id = ${fileId}`
      )[0];

      if (!fileResult || !fileResult.values.length) {
        return [];
      }

      const [filename, mimetype] = fileResult.values[0];
      const tags = [];

      // Tag by file type
      if (mimetype) {
        const [type] = mimetype.split('/');
        tags.push(type); // e.g., 'image', 'video', 'audio'
      }

      // Tag by file extension
      const ext = path.extname(filename).toLowerCase().substring(1);
      if (ext) {
        tags.push(ext);
      }

      // Tag screenshots
      if (filename.toLowerCase().includes('screenshot')) {
        tags.push('screenshot');
      }

      // Tag by common patterns
      if (filename.toLowerCase().includes('backup')) {
        tags.push('backup');
      }
      if (filename.toLowerCase().includes('temp')) {
        tags.push('temp');
      }
      if (filename.toLowerCase().includes('draft')) {
        tags.push('draft');
      }

      // Add tags to file
      const addedTags = [];
      for (const tagName of tags) {
        try {
          const tag = await this.addTagToFile(fileId, tagName, userId, true);
          addedTags.push(tag);
        } catch (error) {
          console.error(`Error adding tag ${tagName}:`, error);
        }
      }

      return addedTags;
    } catch (error) {
      console.error('Error auto-tagging file:', error);
      return [];
    }
  }

  /**
   * Get tag suggestions for file
   */
  async getTagSuggestions(fileId, userId) {
    try {
      const db = getDatabase();
      
      // Get file info
      const fileResult = db.exec(
        `SELECT filename, mimetype FROM files WHERE id = ${fileId}`
      )[0];

      if (!fileResult || !fileResult.values.length) {
        return [];
      }

      const [filename, mimetype] = fileResult.values[0];
      const suggestions = [];

      // Suggest based on file type
      if (mimetype) {
        const [type, subtype] = mimetype.split('/');
        suggestions.push(type, subtype);
      }

      // Suggest based on extension
      const ext = path.extname(filename).toLowerCase().substring(1);
      if (ext) {
        suggestions.push(ext);
      }

      // Get popular tags from user
      const popularTags = db.exec(
        `SELECT t.name, COUNT(ft.id) as count
         FROM tags t
         INNER JOIN file_tags ft ON t.id = ft.tag_id
         INNER JOIN files f ON ft.file_id = f.id
         WHERE f.user_id = ${userId}
         GROUP BY t.id
         ORDER BY count DESC
         LIMIT 5`
      )[0];

      if (popularTags && popularTags.values.length > 0) {
        suggestions.push(...popularTags.values.map(row => row[0]));
      }

      // Remove duplicates
      return [...new Set(suggestions)];
    } catch (error) {
      console.error('Error getting tag suggestions:', error);
      return [];
    }
  }

  /**
   * Search tags
   */
  async searchTags(userId, query) {
    try {
      const db = getDatabase();
      
      const result = db.exec(
        `SELECT * FROM tags 
         WHERE user_id = ${userId} 
         AND name LIKE '%${query}%'
         ORDER BY name ASC
         LIMIT 20`
      )[0];

      if (!result || !result.values.length) {
        return [];
      }

      return result.values.map(row => this.formatTag(row));
    } catch (error) {
      console.error('Error searching tags:', error);
      return [];
    }
  }

  /**
   * Format tag from database row
   */
  formatTag(row) {
    return {
      id: row[0],
      userId: row[1],
      name: row[2],
      color: row[3],
      autoGenerated: row[4] === 1,
      createdAt: row[5]
    };
  }

  /**
   * Get tag statistics
   */
  async getTagStats(userId) {
    try {
      const db = getDatabase();
      
      const total = db.exec(
        `SELECT COUNT(*) FROM tags WHERE user_id = ${userId}`
      )[0];

      const autoGenerated = db.exec(
        `SELECT COUNT(*) FROM tags 
         WHERE user_id = ${userId} AND auto_generated = 1`
      )[0];

      const mostUsed = db.exec(
        `SELECT t.name, COUNT(ft.id) as count
         FROM tags t
         INNER JOIN file_tags ft ON t.id = ft.tag_id
         INNER JOIN files f ON ft.file_id = f.id
         WHERE f.user_id = ${userId}
         GROUP BY t.id
         ORDER BY count DESC
         LIMIT 10`
      )[0];

      return {
        total: total?.values[0][0] || 0,
        autoGenerated: autoGenerated?.values[0][0] || 0,
        mostUsed: mostUsed?.values.map(row => ({
          name: row[0],
          count: row[1]
        })) || []
      };
    } catch (error) {
      console.error('Error getting tag stats:', error);
      return { total: 0, autoGenerated: 0, mostUsed: [] };
    }
  }
}

module.exports = new TaggingService();
